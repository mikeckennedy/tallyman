# Phase 1: Language Variants, Config & Walker

## Goal

Establish the backend foundation for spec categorization. After this phase, running tallyman on a project with directories named `specs`, `specifications`, or `plans` (or with user-designated spec dirs in the config) will correctly categorize docs-category files inside those directories as `specs` instead of `docs`.

## Steps

### 1.1  -  Spec Variant Languages (`languages.py`)

Add a function that creates a spec-category copy of any docs language. Since `Language` is frozen, we create new instances.

**Add to `languages.py`:**

```python
_SPEC_CACHE: dict[Language, Language] = {}


def as_spec(lang: Language) -> Language:
    """Return a spec-category variant of a docs-category language.

    Creates a Language identical to *lang* but with category='specs'.
    Results are cached since Language is frozen and hashable.

    Raises ValueError if lang.category is not 'docs'.
    """
    if lang.category != 'docs':
        raise ValueError(f'as_spec() only applies to docs languages, got {lang.category!r}')
    if lang not in _SPEC_CACHE:
        _SPEC_CACHE[lang] = Language(
            lang.name, 'specs', lang.color, lang.single_line_comment, lang.extensions,
        )
    return _SPEC_CACHE[lang]
```

**Why a cache?** The walker may call `as_spec()` hundreds of times for the same Markdown language. Caching avoids creating duplicate frozen dataclass instances. Since `Language` is frozen and uses slots, it's hashable and works as a dict key.

**Why not pre-define spec languages in `LANGUAGES`?** Because spec variants shouldn't appear in `EXTENSION_MAP`. The extension `.md` should always resolve to docs-category Markdown. The swap to specs happens in the walker based on directory context, not file extension.

### 1.2  -  Config Changes (`config.py`)

Update `load_config` and `save_config` to handle both `[exclude]` and `[specs]` sections.

**Update `load_config`:**

Change the return type from `set[str]` to a structured result containing both excluded dirs and spec dirs.

```python
@dataclass
class TallyConfig:
    """Parsed contents of .tally-config.toml."""
    excluded_dirs: set[str]
    spec_dirs: set[str]


def load_config(config_path: Path) -> TallyConfig:
    """Load a .tally-config.toml and return the configuration."""
    with open(config_path, 'rb') as f:
        data = tomllib.load(f)
    excluded = set(data.get('exclude', {}).get('directories', []))
    specs = set(data.get('specs', {}).get('directories', []))
    return TallyConfig(excluded_dirs=excluded, spec_dirs=specs)
```

**Update `save_config`:**

Accept both sets and write both sections:

```python
def save_config(config_path: Path, excluded_dirs: set[str], spec_dirs: set[str]) -> None:
    """Write a .tally-config.toml file."""
    lines = [
        '# Generated by tallyman. Edit manually or re-run: tallyman --setup',
        '',
        '[exclude]',
        'directories = [',
    ]
    for d in sorted(excluded_dirs):
        lines.append(f'    "{d}",')
    lines.append(']')

    if spec_dirs:
        lines.append('')
        lines.append('[specs]')
        lines.append('directories = [')
        for d in sorted(spec_dirs):
            lines.append(f'    "{d}",')
        lines.append(']')

    lines.append('')
    config_path.write_text('\n'.join(lines), encoding='utf-8')
```

**Note:** The `[specs]` section is only written when there are user-designated spec dirs. Auto-detected spec dirs (by name) don't appear in the config.

**Backward compatibility:** Configs without a `[specs]` section load with an empty `spec_dirs` set. Existing configs continue to work without modification.

### 1.3  -  Update CLI to Use New Config Format (`cli.py`)

Update all `load_config` and `save_config` call sites to use the new `TallyConfig` dataclass:

```python
if existing_config and not args.setup:
    config = load_config(existing_config)
    excluded_dirs = config.excluded_dirs
    spec_dirs = config.spec_dirs
else:
    existing = load_config(existing_config) if existing_config else TallyConfig(set(), set())
    result = run_setup(root, gitignore_spec, existing.excluded_dirs, existing.spec_dirs)
    if result is None:
        print('Setup cancelled.')
        sys.exit(0)
    excluded_dirs, spec_dirs = result
    save_config(config_path, excluded_dirs, spec_dirs)
```

The `run_setup` function signature changes to accept and return spec dirs (detailed in Phase 2). For Phase 1, pass empty sets and ignore spec dirs from the TUI.

Pass `spec_dirs` to the walker:

```python
for file_path, language in walk_project(root, excluded_dirs, gitignore_spec, spec_dirs):
    counts = count_lines(file_path, language)
    file_results.append((language, counts))
```

### 1.4  -  Walker Spec Directory Detection (`walker.py`)

This is the core logic change. The walker needs to:

1. Accept a `spec_dirs` parameter (user-designated spec directories from config).
2. Auto-detect directories named `specs`, `specifications`, or `plans`.
3. Track which directories are "inside" a spec directory (cascading).
4. For docs-category files inside spec directories, swap the language to its spec variant.

**Add constants and helper:**

```python
from tallyman.languages import Language, as_spec, identify_language

SPEC_DIR_NAMES: frozenset[str] = frozenset({'specs', 'specifications', 'plans'})
```

**Update `walk_project` signature and logic:**

```python
def walk_project(
    root: Path,
    excluded_dirs: set[str],
    gitignore_spec: GitIgnoreSpec | None = None,
    spec_dirs: set[str] | None = None,
) -> Iterator[tuple[Path, Language]]:
```

Inside the walk loop, track which relative directory paths are spec directories. A directory is "in spec" if:
- It is directly in `spec_dirs` (user-designated), OR
- Its name (case-insensitive) is in `SPEC_DIR_NAMES` (auto-detected), OR
- Its parent (any ancestor back to root) is a spec directory (cascading)

**Implementation approach  -  `active_spec_roots` set:**

Maintain a set of relative directory paths that are confirmed spec roots. For each directory visited during the walk, check if it's a spec root or if it descends from one. This is efficient because `os.walk` with `topdown=True` visits parents before children.

```python
active_spec_roots: set[str] = set(spec_dirs) if spec_dirs else set()

for dirpath_str, dirnames, filenames in os.walk(root, topdown=True, followlinks=False):
    dirpath = Path(dirpath_str)
    rel_dir = dirpath.relative_to(root)
    rel_dir_str = str(rel_dir) if str(rel_dir) != '.' else ''

    # ... existing directory pruning ...

    # Determine if this directory is inside a spec directory
    dir_is_spec = False
    if rel_dir_str:
        # Check auto-detection by directory name
        if dirpath.name.lower() in SPEC_DIR_NAMES:
            dir_is_spec = True
            active_spec_roots.add(rel_dir_str)
        # Check user-designated spec dirs
        elif rel_dir_str in active_spec_roots:
            dir_is_spec = True
        # Check if parent is a spec dir (cascading)
        else:
            for sr in active_spec_roots:
                if rel_dir_str.startswith(sr + '/'):
                    dir_is_spec = True
                    break

    # Yield files, swapping docs languages to spec variants when in a spec dir
    for filename in sorted(filenames):
        # ... existing gitignore and binary checks ...

        language = identify_language(file_path)
        if language is None:
            continue
        if _is_binary(file_path):
            continue

        # Swap docs → specs if inside a spec directory
        if dir_is_spec and language.category == 'docs':
            language = as_spec(language)

        yield file_path, language
```

**Edge case  -  spec dir inside excluded dir:** Not possible. Excluded dirs are pruned from `os.walk` via `dirnames[:]` filtering, so their children (including any spec dirs) are never visited. This is correct behavior.

**Edge case  -  excluded dir inside spec dir:** The exclusion prune still works. A subdirectory of a spec dir that's excluded gets pruned normally. Only non-excluded children inherit spec status.

### 1.5  -  Verify End-to-End (Manual Testing)

After implementing steps 1.1–1.4, verify by running tallyman on a project that has:
- A `plans/` directory with `.md` files
- A `specs/` directory with `.md` files
- Regular `.md` files outside spec dirs

Expected behavior:
- Markdown files in `plans/` and `specs/` appear with `category='specs'`
- Markdown files elsewhere appear with `category='docs'`
- The aggregator (not yet updated with 'specs' in display order) should still collect them  -  they'll appear as an unnamed category or fall through gracefully

## Acceptance Criteria

- [ ] `as_spec()` creates a spec-variant Language with `category='specs'`
- [ ] `as_spec()` raises ValueError for non-docs languages
- [ ] `as_spec()` caches results (same input → same output object)
- [ ] `load_config` returns `TallyConfig` with both `excluded_dirs` and `spec_dirs`
- [ ] `save_config` writes both `[exclude]` and `[specs]` sections
- [ ] Existing configs without `[specs]` load with empty `spec_dirs`
- [ ] Walker auto-detects directories named `specs`, `specifications`, `plans`
- [ ] Walker accepts user-designated `spec_dirs` and applies them
- [ ] Spec status cascades to subdirectories during walking
- [ ] Only docs-category languages are swapped to spec variants
- [ ] Non-docs files in spec directories retain their original category
- [ ] CLI passes spec dirs through the full pipeline
