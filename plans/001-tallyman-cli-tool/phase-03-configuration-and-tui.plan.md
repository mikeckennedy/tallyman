# Phase 3: Configuration & Textual TUI

## Goal

Implement the `.tally-config.toml` configuration file and the first-run Textual TUI that lets users visually select which directories to include or exclude. After this phase, running `tallyman` in a project without a config file launches the TUI, the user toggles directories, the config is saved, and counting proceeds with those exclusions applied.

## Config File Format

### `.tally-config.toml`

Stored at the root of the analyzed project (next to `.git/`).

```toml
# Generated by tallyman. Edit manually or re-run: tallyman --setup

[exclude]
directories = [
    "static/external",
    "vendor/third-party",
    "docs/_build",
]
```

That's it. Simple. The gitignore-based exclusions are always applied automatically and don't need to be duplicated here. This file only captures the *additional* user-chosen exclusions from the TUI.

**Why not store includes?**  -  Inclusion is the default. We only need to record what the user explicitly turned off. This keeps the file short and easy to understand.

## Steps

### 3.1  -  Config Reader/Writer (`config.py`)

**Reading:**

```python
import tomllib
from pathlib import Path

CONFIG_FILENAME = '.tally-config.toml'


def find_config(root: Path) -> Path | None:
    """Return the config file path if it exists, else None."""
    config_path = root / CONFIG_FILENAME
    return config_path if config_path.is_file() else None


def load_config(config_path: Path) -> set[str]:
    """
    Load a .tally-config.toml and return the set of excluded directory paths
    (relative to project root).
    """
    with open(config_path, 'rb') as f:
        data = tomllib.load(f)
    dirs = data.get('exclude', {}).get('directories', [])
    return set(dirs)
```

**Writing:**

```python
def save_config(config_path: Path, excluded_dirs: set[str]) -> None:
    """
    Write a .tally-config.toml file.
    Sorts directories for deterministic output.
    """
    lines = [
        '# Generated by tallyman. Edit manually or re-run: tallyman --setup',
        '',
        '[exclude]',
        'directories = [',
    ]
    for d in sorted(excluded_dirs):
        lines.append(f'    "{d}",')
    lines.append(']')
    lines.append('')
    config_path.write_text('\n'.join(lines), encoding='utf-8')
```

We write TOML by hand rather than pulling in `tomli-w` because the format is trivially simple.

### 3.2  -  Gitignore Loader (addition to `walker.py`)

Extract the gitignore-loading logic into a reusable function so the TUI can also use it:

```python
import pathspec

def load_gitignore(root: Path) -> pathspec.PathSpec:
    """
    Load gitignore patterns from .gitignore and .git/info/exclude.
    Returns a PathSpec that can match relative paths.
    """
    lines = []
    for ignore_file in [root / '.gitignore', root / '.git' / 'info' / 'exclude']:
        if ignore_file.is_file():
            lines.extend(ignore_file.read_text(encoding='utf-8', errors='replace').splitlines())
    return pathspec.PathSpec.from_lines('gitwildmatch', lines)
```

Also provide a helper to list directories (not files) under the root, respecting gitignore:

```python
def list_directories(root: Path, gitignore_spec: pathspec.PathSpec) -> list[tuple[Path, bool]]:
    """
    Return all directories under root as (path, is_gitignored) tuples.
    Walks top-down, pruning gitignored subtrees.
    Used by the TUI to populate the tree.
    """
```

### 3.3  -  Textual TUI (`tui/setup_app.py`)

This is the main interactive component. It runs when:
1. No `.tally-config.toml` exists (first run), OR
2. The user passes `--setup`.

#### App Structure

The app is a single-screen Textual application with:
- A **header** explaining what to do.
- A **Tree widget** showing the project's directory structure.
- A **footer** with keybindings: Space = toggle, Enter = save & run, Escape/Q = quit without saving.

We use Textual's `Tree` widget (not `DirectoryTree`) because we need full control over:
- Showing only directories, not files.
- Pre-marking gitignored directories as excluded and grayed out.
- Toggling with spacebar.
- Cascading parent toggles to children.

#### Tree Population

```python
from textual.widgets import Tree, Header, Footer
from textual.app import App, ComposeResult

class SetupApp(App):
    """First-run setup: choose which directories to include."""

    BINDINGS = [
        ('space', 'toggle_node', 'Toggle include/exclude'),
        ('enter', 'save_and_exit', 'Save config & run'),
        ('escape', 'quit_no_save', 'Quit without saving'),
    ]

    def __init__(self, root: Path, gitignore_spec: pathspec.PathSpec, existing_exclusions: set[str]):
        super().__init__()
        self.root = root
        self.gitignore_spec = gitignore_spec
        self.existing_exclusions = existing_exclusions
        self.user_excluded: set[str] = set(existing_exclusions)

    def compose(self) -> ComposeResult:
        yield Header()
        yield self._build_tree()
        yield Footer()

    def _build_tree(self) -> Tree:
        tree = Tree(self.root.name)
        tree.root.data = {'path': '', 'gitignored': False, 'excluded': False}
        self._populate(tree.root, self.root, '')
        tree.root.expand_all()
        return tree
```

#### Node Data

Each tree node's `data` dict holds:
```python
{
    'path': str,          # Relative path from project root (e.g. 'static/external')
    'gitignored': bool,   # True if matched by .gitignore
    'excluded': bool,     # True if user has toggled it off
}
```

#### Populating the Tree

```python
def _populate(self, parent_node, dir_path: Path, rel_path: str) -> None:
    """Recursively add subdirectories to the tree."""
    try:
        entries = sorted(dir_path.iterdir())
    except PermissionError:
        return

    for entry in entries:
        if not entry.is_dir() or entry.name.startswith('.'):
            continue

        child_rel = f'{rel_path}/{entry.name}'.lstrip('/')
        is_gitignored = self.gitignore_spec.match_file(child_rel + '/')
        is_excluded = child_rel in self.user_excluded or is_gitignored

        # Build the label with visual indicators
        if is_gitignored:
            label = f'[dim]{entry.name} (gitignored)[/dim]'
        elif is_excluded:
            label = f'[red]✗[/red] [dim]{entry.name}[/dim]'
        else:
            label = f'[green]✓[/green] {entry.name}'

        node = parent_node.add(
            label,
            data={
                'path': child_rel,
                'gitignored': is_gitignored,
                'excluded': is_excluded,
            },
        )

        # Don't recurse into gitignored dirs (they're fully excluded)
        if not is_gitignored:
            self._populate(node, entry, child_rel)
```

#### Toggle Logic

When the user presses Space on a node:

```python
def action_toggle_node(self) -> None:
    tree = self.query_one(Tree)
    node = tree.cursor_node
    if node is None or node.data is None:
        return

    # Can't toggle gitignored dirs  -  they're always excluded
    if node.data['gitignored']:
        return

    # Toggle this node
    new_state = not node.data['excluded']
    self._set_excluded(node, new_state)

def _set_excluded(self, node, excluded: bool) -> None:
    """Set excluded state on a node and cascade to all children."""
    node.data['excluded'] = excluded
    rel_path = node.data['path']

    if excluded:
        self.user_excluded.add(rel_path)
    else:
        self.user_excluded.discard(rel_path)

    # Update label
    name = Path(rel_path).name if rel_path else self.root.name
    if excluded:
        node.set_label(f'[red]✗[/red] [dim]{name}[/dim]')
    else:
        node.set_label(f'[green]✓[/green] {name}')

    # Cascade to children
    for child in node.children:
        if child.data and not child.data['gitignored']:
            self._set_excluded(child, excluded)
```

This is the critical parent-child cascading behavior. Toggling "static" off sets "static/external", "static/images", etc. all to excluded.

#### Save and Exit

```python
def action_save_and_exit(self) -> None:
    """Save the config file and exit the app."""
    # Clean up: remove children whose parents are already excluded
    # (only store the highest-level exclusion)
    cleaned = self._clean_exclusions(self.user_excluded)
    self.result = cleaned  # Return to caller via app.run()
    self.exit(cleaned)

def _clean_exclusions(self, excluded: set[str]) -> set[str]:
    """
    Remove redundant child paths when a parent is already excluded.
    e.g. if 'vendor' is excluded, remove 'vendor/sub1', 'vendor/sub2'.
    """
    sorted_paths = sorted(excluded)
    cleaned = set()
    for path in sorted_paths:
        if not any(path.startswith(p + '/') for p in cleaned):
            cleaned.add(path)
    return cleaned

def action_quit_no_save(self) -> None:
    """Exit without saving."""
    self.exit(None)
```

#### CSS Styling

```python
CSS = """
Tree {
    margin: 1 2;
}

Header {
    dock: top;
}

Footer {
    dock: bottom;
}
"""
```

#### Running the TUI

The entry point function called from `cli.py`:

```python
def run_setup(root: Path, gitignore_spec, existing_exclusions: set[str]) -> set[str] | None:
    """
    Launch the TUI setup app.
    Returns the set of excluded directory paths, or None if user quit without saving.
    """
    app = SetupApp(root, gitignore_spec, existing_exclusions)
    result = app.run()
    return result
```

### 3.4  -  Wire config and TUI into `cli.py`

Update the main flow:

```python
def main() -> None:
    parser = build_parser()
    args = parser.parse_args()
    root = Path(args.path).resolve()

    if not root.is_dir():
        print(f'Error: {root} is not a directory', file=sys.stderr)
        sys.exit(1)

    # Load gitignore
    gitignore_spec = load_gitignore(root)

    # Load or create config
    config_path = root / CONFIG_FILENAME
    existing_config = find_config(root)

    if existing_config and not args.setup:
        # Config exists, load it
        excluded_dirs = load_config(existing_config)
    else:
        # First run or --setup: launch TUI
        existing_exclusions = load_config(existing_config) if existing_config else set()
        result = run_setup(root, gitignore_spec, existing_exclusions)
        if result is None:
            # User quit without saving
            print('Setup cancelled.')
            sys.exit(0)
        excluded_dirs = result
        save_config(config_path, excluded_dirs)

    # Walk, count, aggregate, display
    file_results = []
    for file_path, language in walk_project(root, excluded_dirs):
        counts = count_lines(file_path, language)
        file_results.append((language, counts))

    result = aggregate(iter(file_results))
    # Display (Phase 4 replaces this with rich output)
    for stats in result.by_language:
        print(f'{stats.language.name}: {stats.total_lines:,} lines')
```

### 3.5  -  Tests

**`test_config.py`:**
- `save_config` then `load_config` round-trips correctly.
- `load_config` on a file with no `[exclude]` section returns empty set.
- `find_config` returns None when no file exists.
- `find_config` returns the path when the file exists.

**`test_walker.py` additions:**
- `load_gitignore` correctly parses `.gitignore` patterns.
- `list_directories` marks gitignored dirs correctly.
- Walker respects `excluded_dirs` loaded from config.

**TUI testing:**
- Textual provides `pilot` for automated testing. Write at least one test:
  - Create a tmp dir with a few subdirectories.
  - Launch `SetupApp`, navigate to a directory, press Space to toggle, press Enter.
  - Verify the returned exclusion set is correct.

## Acceptance Criteria

- [ ] `.tally-config.toml` is created on first run after the TUI completes
- [ ] Subsequent runs skip the TUI and use the saved config
- [ ] `tallyman --setup` forces the TUI even when config exists
- [ ] TUI displays directory tree (directories only, no files)
- [ ] Gitignored directories appear grayed out and cannot be toggled
- [ ] Spacebar toggles a directory between included and excluded
- [ ] Toggling a parent cascades to all children
- [ ] Pressing Enter saves the config and continues to counting
- [ ] Pressing Escape exits without saving
- [ ] Redundant child exclusions are cleaned up (only highest-level parent stored)
- [ ] Config round-trips correctly (save then load)
- [ ] All tests pass
- [ ] Ruff passes with no errors
