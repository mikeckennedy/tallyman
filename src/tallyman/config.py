"""Configuration file handling for .tally-config.toml."""

from __future__ import annotations

import os
import tomllib
from dataclasses import dataclass, field
from pathlib import Path

CONFIG_FILENAME = '.tally-config.toml'


@dataclass
class TallyConfig:
    """Parsed contents of .tally-config.toml."""

    excluded_dirs: set[str] = field(default_factory=set)
    spec_dirs: set[str] = field(default_factory=set)


def find_config(root: Path) -> Path | None:
    """Search for .tally-config.toml starting at *root* and walking up.

    Returns the first config file found, or None.
    """
    current = root.resolve()
    while True:
        config_path = current / CONFIG_FILENAME
        if config_path.is_file():
            return config_path
        parent = current.parent
        if parent == current:
            return None
        current = parent


def load_config(config_path: Path) -> TallyConfig:
    """Load a .tally-config.toml and return the configuration."""
    with config_path.open('rb') as f:
        data = tomllib.load(f)
    excluded = set(data.get('exclude', {}).get('directories', []))
    specs = set(data.get('specs', {}).get('directories', []))
    return TallyConfig(excluded_dirs=excluded, spec_dirs=specs)


def discover_nested_configs(root: Path) -> TallyConfig:
    """Scan subdirectories for .tally-config.toml and merge their settings.

    Paths from nested configs are translated to be relative to *root*.
    Only non-root configs are considered (the root config is loaded separately).
    Hidden directories are skipped for performance.
    """
    merged_excluded: set[str] = set()
    merged_specs: set[str] = set()

    for dirpath_str, dirnames, _filenames in os.walk(root, topdown=True, followlinks=False):
        # Skip hidden directories (e.g. .git, .venv)
        dirnames[:] = sorted(d for d in dirnames if not d.startswith('.'))

        dirpath = Path(dirpath_str)
        rel_dir = dirpath.relative_to(root)
        rel_dir_str = str(rel_dir) if rel_dir.parts else ''

        if not rel_dir_str:
            continue

        config_file = dirpath / CONFIG_FILENAME
        if config_file.is_file():
            try:
                nested = load_config(config_file)
                for excl in nested.excluded_dirs:
                    merged_excluded.add(f'{rel_dir_str}/{excl}')
                for spec in nested.spec_dirs:
                    merged_specs.add(f'{rel_dir_str}/{spec}')
            except Exception:
                pass  # Skip malformed configs

    return TallyConfig(excluded_dirs=merged_excluded, spec_dirs=merged_specs)


def save_config(config_path: Path, excluded_dirs: set[str], spec_dirs: set[str]) -> None:
    """Write a .tally-config.toml file. Sorts directories for deterministic output."""
    lines = [
        '# Generated by tallyman. Edit manually or re-run: tallyman --setup',
        '',
        '[exclude]',
        'directories = [',
    ]
    for d in sorted(excluded_dirs):
        lines.append(f'    "{d}",')
    lines.append(']')

    if spec_dirs:
        lines.append('')
        lines.append('[specs]')
        lines.append('directories = [')
        for d in sorted(spec_dirs):
            lines.append(f'    "{d}",')
        lines.append(']')

    lines.append('')
    config_path.write_text('\n'.join(lines), encoding='utf-8')
